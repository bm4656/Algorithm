# 버블 정렬(Bubble Sort)

한번 순회할 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여서버블 정렬이다.

- 데이터를 두 개씩 묶어서 비교한 후 크기가 큰 쪽이 오른쪽으로 가도록 자리를 바꿔가며 크기가 큰 데이터를 오른쪽으로 민다.
- 1회전이 끝남과 동시에 이 리스트에서 가장 큰 값이 오른쪽으로 가기 때문에 맨 오른쪽 자리가 결정난다.
- **즉, n번째 정렬 회차가 끝나면 뒤에서 n번째 자리의 데이터가 확정된다.**

### Big O

- **Worst Case: O(n^2)**: 정렬이 하나도 안되어있는 경우
- **Best Case: O(n)**: 이미 정렬이 되어있는 경우

버블 정렬은 최악의 경우에 O(n^2)의 시간 복잡도를 가진다. 왜냐하면 각 자리를 찾기 위해서 n번의 순회를 해야하며 n번의 회전 동안에 요소의 개수만큼 또 순회를 해야하기 때문이다. 그러나 이미 정렬이 되어있는 경우에는 한 번의 순회로 정렬 여부를 알 수 있다.

- 따라서 거의 모든 상황에서 최악의 성능을 보여주지만, 이미 정렬된 자료에서는 1번만 순회하면 되기 때문에 최선의 성능을 보여주는 알고리즘이다.

### 장점

버블 정렬은 **in place** 알고리즘이기 때문에 **메모리가 절약된다**. 여기서 "in place"라는 것은 자료를 정렬할 때 추가적인 메모리 공간이 필요한 것이 아니고 데이터가 저장된 그 공간 내에서 정렬을 한다는 뜻이다.

또한 구현하기 매우 쉽다다. 그 외에도 이미 정렬된 데이터를 순회하는 경우 O(n)번만 순회하면 되기 때문에 정렬이 되었는지 안되었는지 테스트하는 용도로 사용될 수도 있다.

### 단점

버블 정렬의 가장 큰 단점은 **자료의 개수가 많아질수록 성능이 매우 떨어진다**는 점이다. 왜냐하면 최악의 경우 O(n^2)이 소요되기 때문이다. 만약 데이터가 위 이미지처럼 5개밖에 없다면 최대 25번 순회를 해야하지만 데이터가 1,000개라면 1,000,000번이나 순회를 해야한다.

### **Stable**

버블 정렬은 중복 데이터가 있을 경우 데이터의 위치를 교환하지 않고 지나가기 때문에 **stable한 정렬**이다. 여기서 stable이라는 뜻은 중복 데이터가 있는 경우에 기존 중복 데이터의 순서가 정렬이 다 끝난 이후에도 유지되는 정렬을 말한다.

## javaScript에서 구현

```js
function bubbleSort(array) {
  const len = array.length;
  let tmp = null;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len; j++) {
      if (array[i] > array[j + 1]) {
        //Swap
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        tmp = null;
      }
    }
    console.log(`${i + 1}회전 ${array}`);
  }
  return array;
}
console.log(bubbleSort([5, 4, 3, 2, 1]));
```
